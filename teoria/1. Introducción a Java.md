# ¬øQu√© es Java?

Java es un lenguaje de programaci√≥n orientado a objetos (POO), tipado est√°tico y multiplataforma. La idea central es ‚Äúescribe una vez, ejecuta en cualquier lugar‚Äù: el c√≥digo fuente (.java) se compila a bytecode (.class), y ese bytecode se ejecuta en la M√°quina Virtual de Java (JVM - Java Virtual Machine), que existe para distintos sistemas operativos (Windows, Linux, macOS).

Puntos clave:

- **Orientado a objetos**: modela el problema con clases y objetos; usa encapsulamiento, herencia y polimorfismo.
- **Multiplataforma**: el mismo .class corre en cualquier SO con una JVM.
- **Tipado est√°tico**: los tipos se verifican en compilaci√≥n (m√°s seguridad y menos errores en runtime).
- **Amplia biblioteca est√°ndar**: colecciones, E/S, redes, concurrencia, etc.
- **Ecosistema maduro**: herramientas como JDK, Maven/Gradle, y editores/IDEs (VS Code, IntelliJ, Eclipse).

Ejemplo de c√≥digo de Hola Mundo en Java:

```java
public class Main {

public static void main(String[] args) {
System.out.println("Hola, mundo");
  }
}
```





# El m√©todo main en Java

En Java, todo programa comienza su ejecuci√≥n en un m√©todo especial llamado main.

Es el punto de entrada del programa: cuando ejecutamos un archivo .class o un proyecto, la M√°quina Virtual de Java (JVM) busca este m√©todo para empezar a correr el c√≥digo.



### Declaraci√≥n est√°ndar

```Java
public class MiPrograma {
    public static void main(String[] args) {
        System.out.println("Hola, mundo!");
    }
}
```



### Desglose de la declaraci√≥n

1. **`public`**
   - Es un **modificador de acceso**.
   - Significa que el m√©todo puede ser llamado desde **cualquier lugar**.
   - La JVM necesita acceder al m√©todo, por eso debe ser `public`.
2. **`static`**
   - Significa que el m√©todo pertenece a la **clase**, no a un objeto.
   - Esto es necesario porque, al iniciar el programa, todav√≠a no existe ning√∫n objeto de la clase.
   - La JVM puede ejecutar el m√©todo sin tener que crear una instancia primero.
3. **`void`**
   - Es el **tipo de retorno** del m√©todo.
   - `void` significa que el m√©todo no devuelve ning√∫n valor.
   - El `main` simplemente ejecuta el programa, no tiene que devolver datos.
4. **`main`**
   - Es el **nombre del m√©todo**.
   - La JVM **siempre busca exactamente este nombre** para comenzar la ejecuci√≥n.
   - Si el nombre cambia, **el programa no arranca**.
5. **`String[] args`**
   - Es el **par√°metro del m√©todo**.
   - Es un **arreglo de cadenas de texto (strings)**.
   - Sirve para recibir **argumentos desde la l√≠nea de comandos** cuando se ejecuta el programa.
   - Ejemplo:

```bash
java MiPrograma Hola Mundo
```



### Resumen

- **`main` es el punto de inicio de un programa en Java.**
- La firma completa debe ser **`public static void main(String[] args)`**.
- Cada palabra en su declaraci√≥n tiene un rol espec√≠fico:
  - `public`: accesible desde la JVM.
  - `static`: no depende de objetos.
  - `void`: no devuelve valores.
  - `String[] args`: par√°metros de entrada desde la consola.





# Entrada y salida de datos en Java

## Salida con `System.out`

- `System.out.println(...)`: imprime y **agrega salto de l√≠nea**.
- `System.out.print(...)`: imprime **sin** salto de l√≠nea.
- `System.out.printf(...)`: imprime con **formato** (similar a C), por ejemplo `%.2f` para 2 decimales.

Ejemplo:

```java
double promedio = 8.326;
System.out.println("Promedio (println): " + promedio);
System.out.print("Sin salto de l√≠nea -> ");
System.out.println("ahora s√≠ hay salto");
System.out.printf("Promedio con 2 decimales: %.2f%n", promedio);

```



## Entrada con `Scanner`

Para leer desde consola, se usa `java.util.Scanner` leyendo de `System.in`.

**M√©todos m√°s usados:**

- Texto: `next()` (palabra), `nextLine()` (l√≠nea completa)
- N√∫meros: `nextInt()`, `nextLong()`, `nextDouble()`, `nextFloat()`
- Booleanos: `nextBoolean()`
- Caracter: no hay `nextChar()`: se usa `next().charAt(0)`

Nota: si quieren un ejemplo de mas m√©todos usados para leer diferentes tipos de dato pueden ir al archivo `tiposDeScanner.java` en la carpeta primeraClase del repositorio de GitHub [https://github.com/MauriJC/POO1-2025], all√≠ est√°n casi todos los casos de uso para la entrada.



**Ejemplo completo (nombre, edad, altura, inicial):**

```java
import java.util.Scanner;

public class EntradaScanner {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Edad (int): ");
        int edad = sc.nextInt();
        sc.nextLine(); // limpiar el fin de l√≠nea pendiente

        System.out.print("Nombre completo (String): ");
        String nombre = sc.nextLine();

        System.out.print("Altura en metros (double): ");
        double altura = sc.nextDouble();

        System.out.print("Inicial de tu nombre (char): ");
        char inicial = sc.next().charAt(0);

        System.out.println("\nResumen:");
        System.out.println("Nombre: " + nombre);
        System.out.println("Edad: " + edad);
        System.out.println("Altura: " + altura);
        System.out.println("Inicial: " + inicial);

        // Nota: en ejercicios de consola b√°sicos, suele omitirse sc.close()
        // para no cerrar System.in (evita problemas si luego quer√©s leer otra vez).
    }
}

```



**Importante (trampa com√∫n):**
 Si us√°s `nextInt()` / `nextDouble()` y luego `nextLine()`, limpi√° el **fin de l√≠nea** con un `sc.nextLine()` intermedio (como arriba), o tu `nextLine()` puede ‚Äúcomerse‚Äù un Enter vac√≠o.





# Ciclos repetitivos: `for` y `while`

## 1. `for` (repeticiones contadas)

**Sintaxis:**

```java
for (inicializacion; condicion; actualizacion) {
    // cuerpo del bucle
}
```



- **`inicializaci√≥n`**: define el contador (p. ej. `int i = 1`)
- **`condici√≥n`**: mientras sea `true`, se repite (p. ej. `i <= 10`)
- **`actualizaci√≥n`**: c√≥mo cambia el contador (`i++`, `i += 2`, etc.)



**Ejemplos:**

```java
// 1..10
for (int i = 1; i <= 10; i++) {
    System.out.println(i);
}

// Contar hacia atr√°s: 10..1
for (int i = 10; i >= 1; i--) {
    System.out.println(i);
}

// Suma 1..N
int N = 5, suma = 0;
for (int i = 1; i <= N; i++) {
    suma += i;
}
System.out.println("Suma 1..N = " + suma);

```





## 2. `while` (repeticiones condicionadas)

**Sintaxis:**

```java
while (condicion) {
    // cuerpo del bucle
}
```



Se repite **mientras** la condici√≥n sea verdadera.

Deb√©s encargarte de **modificar el estado** dentro del bucle o tendr√°s un bucle infinito.



**Ejemplos**:

``` java
// 1..10 con while
int i = 1;
while (i <= 10) {
    System.out.println(i);
    i++;
}

// Men√∫ simple con while
import java.util.Scanner;

Scanner sc = new Scanner(System.in);
int opcion = -1;

while (opcion != 3) {
    System.out.println("\n--- MEN√ö ---");
    System.out.println("1) Sumar");
    System.out.println("2) Promedio de 3 notas");
    System.out.println("3) Salir");
    System.out.print("Opci√≥n: ");
    opcion = sc.nextInt();

    if (opcion == 1) {
        System.out.print("Ingrese dos enteros: ");
        int a = sc.nextInt(), b = sc.nextInt();
        System.out.println("Suma = " + (a + b));
    } else if (opcion == 2) {
        double sumaNotas = 0;
        for (int k = 1; k <= 3; k++) {
            System.out.print("Nota " + k + ": ");
            sumaNotas += sc.nextDouble();
        }
        System.out.printf("Promedio = %.2f%n", (sumaNotas / 3));
    } else if (opcion != 3) {
        System.out.println("Opci√≥n inv√°lida");
    }
}

```



**Notas √∫tiles:**

- `break;` sale del bucle actual.
- `continue;` salta a la siguiente iteraci√≥n. (Tambi√©n sirven con el `for`)
- Existe `do { ... } while (condicion);` (ejecuta al menos una vez), pero con `for` y `while` es posible todo lo b√°sico.





# Funciones en Java (m√©todos)



## Concepto

Una **funci√≥n** (en Java, **m√©todo**) es un **bloque de c√≥digo reutilizable** que realiza una tarea.
 Ventajas:

- **Reutilizaci√≥n** y **modularidad** (c√≥digo m√°s claro y mantenible).
- **Abstracci√≥n** (oculta detalles; s√≥lo importa ‚Äúqu√© hace‚Äù).
- Facilita **pruebas** y **depuraci√≥n**.



Nota de color del lenguaje:

En Java, lo que com√∫nmente llamamos *funciones* en otros lenguajes, aqu√≠ se llaman **m√©todos**.
üëâ T√©cnicamente **todas las funciones en Java son m√©todos**, porque siempre est√°n definidas dentro de una clase. 
¬øCu√°l es la diferencia? Una funci√≥n no pertenece a una clase y el m√©todo si, pero en Java, al ser todo una clase, son siempre m√©todos. 



## Sintaxis de un m√©todo

Un m√©todo en Java se compone de varias partes:

```java
[modificadores] tipoDeRetorno nombreMetodo(par√°metros) {
    // cuerpo
    return ...; // si no es void
}
```



### **Modificadores**

Los modificadores controlan **el acceso y comportamiento** del m√©todo. Algunos ejemplos:

- **public** ‚Üí Se puede usar desde cualquier parte del programa.
- **private** ‚Üí Solo puede ser usado dentro de la misma clase.
- **protected** ‚Üí Puede ser usado en la misma clase, en clases hijas o en el mismo paquete.
- **static** ‚Üí El m√©todo pertenece a la clase, no a un objeto. Se puede usar sin crear instancias.
- **final** ‚Üí El m√©todo no puede ser sobreescrito en una subclase.
- **abstract** ‚Üí Declara un m√©todo sin implementaci√≥n, que deber√° ser definido en una subclase.





### **Tipo de retorno**

Indica qu√© valor devuelve el m√©todo:

- **void** ‚Üí No devuelve nada.
- **int, double, String, boolean‚Ä¶** ‚Üí Devuelve un valor de ese tipo.
- **clases u objetos** ‚Üí Un m√©todo tambi√©n puede devolver un objeto.

üëâ Ejemplo de distintos tipos de retorno:

```java
public int sumar(int a, int b) {
    return a + b; // retorna un entero
}

public String saludar(String nombre) {
    return "Hola " + nombre; // retorna un String
}

public void mostrarMensaje() {
    System.out.println("No devuelvo nada, solo muestro en pantalla");
}
```





### **Par√°metros**

Los par√°metros son **valores de entrada** que recibe un m√©todo.
 Dentro del m√©todo, se usan como **variables locales** con el nombre que se les asign√≥.

Ejemplo:

``` java
public void mostrarEdad(int edad) {
    System.out.println("Tu edad es: " + edad);
}		
```



üëâ Particularidades:

- Cada par√°metro debe declararse con un **tipo de dato**.
- El nombre del par√°metro es el que se usa dentro del m√©todo.
- Se pueden tener m√∫ltiples par√°metros separados por comas.
- Si declaras una variable con el mismo nombre dentro del m√©todo, tendr√°s un **error de sombra (shadowing)**.



Ejemplo del error de shadowing:

``` java
public static void saludar(String nombre) {
    String nombre; // ‚ùå Esto genera error
    System.out.println(nombre);
}
```







En esta etapa usaremos **m√©todos `static`** para llamarlos directamente desde `main`. M√°s adelante, cuando veamos Clases y Objetos veremos como esto no es siempre necesario.



# M√©todos sin y con tipo (con retorno)



## M√©todos sin tipo, Qu√© son?



Son m√©todos que **no devuelven ning√∫n valor**. Su prop√≥sito principal es **realizar una acci√≥n**: imprimir, modificar el estado interno de un objeto, escribir en un fichero, etc.



Sintaxis b√°sica

``` java
[modificadores] void nombreMetodo([parametros]) {
    // cuerpo: acciones / efectos
}
```



## Caracter√≠sticas

- **No pueden usar `return <valor>;`** ‚Äî s√≥lo `return;` para salir anticipadamente si quer√©s.
- Se usan para **operaciones con efectos secundarios** (I/O, modificar atributos, actualizar colecciones).
- Pueden ser `static` (pertenecen a la clase) o de instancia (necesitan un objeto).



## Ejemplos

``` java
public class EjemplosVoid {

    // m√©todo est√°tico que imprime (sin retornar)
    public static void saludar() {
        System.out.println("¬°Hola!");
    }

    // m√©todo de instancia que modifica el estado del objeto
    private int contador = 0;

    public void incrementar() {
        contador++; // efecto sobre el estado interno
    }

    // retorno anticipado (sin valor)
    public void procesar(int n) {
        if (n <= 0) return; // termina el m√©todo aqu√≠
        // resto del procesamiento
    }
}
```



### a) **Sin par√°metros y sin retorno (void)**

```java
public class MetodosDemo {
    public static void saludar() {
        System.out.println("¬°Bienvenidos a POO 1!");
    }

    public static void main(String[] args) {
        saludar();
    }
}
```



### b) **Con par√°metros y sin retorno (void)**

``` java
public class MetodosDemo {
    public static void mostrarSuma(int a, int b) {
        int r = a + b;
        System.out.println("La suma es: " + r);
    }

    public static void main(String[] args) {
        mostrarSuma(5, 7);
    }
}
```



## Cu√°ndo usar `void`

- Cuando el objetivo es **ejecutar una acci√≥n**, no calcular un valor.
- Cuando el m√©todo debe **mutar** objetos o el estado de la clase.
- Evita mezclar: si una operaci√≥n produce un resultado √∫til, mejor devolverlo en vez de s√≥lo imprimirlo.



# M√©todos con tipo (con retorno)

## Qu√© son

Son m√©todos que **devuelven un valor** de un tipo declarado (primitivo, objeto, arreglo, `Optional`, gen√©rico, etc.). La firma indica el tipo de retorno y el m√©todo **debe** terminar en un `return <valor>;` compatible.

## Sintaxis b√°sica

```java
[modificadores] Tipo nombreMetodo([parametros]) {
    // calcular resultado
    return resultado; // debe ser del tipo declarado (o compatible)
}
```



## Reglas importantes

- Si el m√©todo declara un tipo distinto a `void`, **tiene que devolver** un valor en todos los caminos de ejecuci√≥n (compilador lo verifica).
- Pueden haber **varios `return`** (retornos tempranos) pero siempre retornando el tipo correcto.
- Si devuelves un objeto, puedes retornar `null` ‚Äî pero es mejor usar `Optional<T>` para valores opcionales.



## Ejemplos

```java
public class EjemplosReturn {

    // devuelve entero
    public static int sumar(int a, int b) {
        return a + b;
    }

    // devuelve String (puede devolver null, mejor Optional)
    public String obtenerNombre(boolean existe) {
        if (!existe) return null;
        return "Mauricio";
    }

    // devuelve lista (mejor devolver copia defensiva si es interna)
    private List<String> tags = new ArrayList<>();

    public List<String> getTags() {
        return new ArrayList<>(tags); // copia defensiva: evita que el llamador modifique la lista original
    }

    // devuelve Optional para ausencia controlada
    public Optional<String> buscarPorId(int id) {
        if (id == 0) return Optional.empty();
        return Optional.of("Encontrado");
    }
}
```



## Tipos de retorno comunes

- **Primitivos**: `int`, `double`, `boolean` ‚Äî siempre devuelven un valor concreto.
- **Objetos**: `String`, `List<T>`, instancias de tus clases. `T` puedes reemplazarlo por el tipo de dato que quieras, pero hace referencia a que ser√° una lista de instancias de tipo `T`.
- **Arrays**: `int[]`, `String[]`.
- **Optional**: `Optional<T>` (desde Java 8) para evitar `null`.
- **Gen√©ricos**: `T`, `List<T>`, `Map<K,V>`.





# Par√°metros: c√≥mo se usan dentro del m√©todo

## Punto clave: nombres y alcance

- Los par√°metros son **variables locales** dentro del m√©todo; declar√°s tipo y nombre: `int n`, `String nombre`.
- **No pod√©s redeclarar** el mismo nombre dentro del m√©todo (p. ej. `String nombre;` si ya existe el par√°metro `nombre` ‚Äî eso da error).
- Dentro del m√©todo us√°s el nombre del par√°metro como cualquier variable.



``` java
public void saludar(String nombre) {
    // correcto: uso directo del par√°metro
    System.out.println("Hola " + nombre);

    // incorrecto: redeclarar
    // String nombre; // ERROR: variable ya declarada
}
```





## Paso por valor en Java

- Java **siempre pasa por valor**.
  - **Primitivos**: se copia el valor; modificarlo dentro del m√©todo **no** cambia la variable original fuera.
  - **Objetos**: se copia la **referencia**; dentro del m√©todo pod√©s modificar el objeto referenciado y esos cambios **se ven fuera**. Pero si reasign√°s la referencia dentro del m√©todo, la reasignaci√≥n **no** afecta a la referencia externa.



Ejemplo:

``` java
public static void cambiarPrimitivo(int x) { x = 99; } // no afecta al original
public static void modificarLista(List<String> l) { l.add("a"); } // s√≠ afecta al original
```

``` java
public class EjemploPasoPorValor {
    public static void main(String[] args) {
        int x = 10;
        cambiarPrimitivo(x); // Se pasa una copia de x
        System.out.println(x); // Sigue siendo 10 (no cambi√≥).

        List<String> lista = new ArrayList<>();
        modificarLista(lista); // Se pasa una copia de la referencia
        System.out.println(lista); // Muestra ["a"] (s√≠ se modific√≥ el objeto referenciado).
    }

    public static void cambiarPrimitivo(int x) { 
        x = 99; // Solo modifica la copia local.
    }

    public static void modificarLista(List<String> list) { 
        list.add("a"); // Modifica el objeto original.
    }
}
```







## Buenas pr√°cticas con par√°metros

- Nombre descriptivo (`nombreUsuario`, `cantidad`, `listaAlumnos`).
- Evitar mutar par√°metros si quer√©s mantener pureza; o dejar expl√≠cito en la documentaci√≥n que se mutan.
- Si el par√°metro es una colecci√≥n y no quer√©s que se modifique: copia defensiva o `Collections.unmodifiableList(...)`.











